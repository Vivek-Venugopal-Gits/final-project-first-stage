SECTION: Tutorial Overview - Writing Your First Django App, Part 2
PURPOSE:
This section continues from the previous tutorial by setting up the database, creating initial models for the poll application, and introducing the automatically-generated admin site.
SECTION: Database Configuration
CONCEPT:
The default database configuration in mysite/settings.py uses SQLite for simplicity, as it is included with Python and requires no additional installation. For production or scalable projects, consider switching to databases like PostgreSQL to avoid future migration issues.
Edit mysite/settings.py to set TIME_ZONE to your specific time zone.
USAGE GUIDELINES:
USE WHEN:

Starting with Django for quick prototyping or learning.
DO NOT USE WHEN:
Requiring high scalability or concurrent access in production environments.

SECTION: Installed Apps Overview
CONCEPT:
The INSTALLED_APPS setting in mysite/settings.py lists activated Django applications for the project. These can be reused across projects.
Default installed apps include:

django.contrib.admin: Provides the admin site.
django.contrib.auth: Handles authentication.
django.contrib.contenttypes: Offers a generic interface to models.
django.contrib.sessions: Manages sessions.
django.contrib.messages: Supports temporary message storage.
django.contrib.staticfiles: Manages static files.

These apps require database tables, which must be created before use.
SECTION: Applying Initial Migrations
CONCEPT:
Run the migrate command to create necessary database tables based on INSTALLED_APPS and database settings.
COMMAND:
python manage.py migrate
This command applies migrations, creating tables for default apps. Verify tables using database-specific commands like \dt for PostgreSQL, SHOW TABLES; for MySQL/MariaDB, .tables for SQLite, or SELECT TABLE_NAME FROM USER_TABLES; for Oracle.
USAGE GUIDELINES:
USE WHEN:

Initializing the database or applying model changes.
DO NOT USE WHEN:
Specific apps are unnecessary; remove them from INSTALLED_APPS first to avoid creating unneeded tables.

SUMMARY:

Default apps provide core functionality like admin and auth.
Migrations automate table creation for activated apps.
Customize INSTALLED_APPS to fit project needs.

SECTION: Model Design Philosophy
CONCEPT:
Models define the database layout and metadata as the single source of data information, following the DRY principle. Define models once to automatically derive database schemas and migrations.
Migrations are derived from models and track schema history for updates without manual intervention.
SECTION: Creating Poll Models
CONCEPT:
Define Question and Choice models in polls/models.py. Question includes question text and publication date. Choice includes choice text, vote count, and a foreign key to Question.
Code for polls/models.py:
from django.db import models

class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField("date published")

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
Each model subclasses django.db.models.Model. Fields use classes like CharField (with max_length) for strings, DateTimeField for dates, IntegerField (with default) for numbers, and ForeignKey for relationships.
Field names are machine-readable and become database column names. Optional first arguments provide human-readable names. ForeignKey defines many-to-one relationships.
VERSION AND SCOPE ANCHORS:
DJANGO VERSION: 6.0
PYTHON VERSION: 3.12 and later
APPLICABILITY:

Models support common relationships: many-to-one, many-to-many, one-to-one.

SECTION: Activating the Poll App
CONCEPT:
Add the poll app to the project by including its configuration in INSTALLED_APPS.
Edit mysite/settings.py:
INSTALLED_APPS = [
    "polls.apps.PollsConfig",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]
SECTION: Generating Migrations for Models
CONCEPT:
Use makemigrations to detect model changes and create migration files.
COMMAND:
python manage.py makemigrations polls
This generates files like polls/migrations/0001_initial.py for new models.
Migrations store schema changes on disk for version control.
SECTION: Viewing Migration SQL
CONCEPT:
Use sqlmigrate to preview the SQL that a migration would execute.
COMMAND:
python manage.py sqlmigrate polls 0001
Output includes CREATE TABLE statements tailored to the database, with automatic primary keys, foreign keys, and indexes. Table names combine app and model names. Foreign keys append _id and use constraints.
Output varies by database (e.g., PostgreSQL uses bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY).
sqlmigrate does not execute changes; it displays SQL for review.
SECTION: Applying Model Migrations
CONCEPT:
Apply migrations to synchronize model changes with the database schema.
COMMAND:
python manage.py migrate
This applies unapplied migrations, including the new poll models.
Migrations enable live database upgrades without data loss.
Process for model changes:

Edit models.py.
Run makemigrations to create migrations.
Run migrate to apply changes.

Separate commands allow committing migrations to version control for team and production use.
SUMMARY:

Models generate database schemas and APIs.
Add apps to INSTALLED_APPS to activate.
Use makemigrations and migrate for schema updates.
Migrations support versioned, data-preserving changes.

SECTION: Interacting with Models via Shell
CONCEPT:
Use the Django shell for interactive database API exploration.
COMMAND:
python manage.py shell
This sets DJANGO_SETTINGS_MODULE and imports models automatically.
Example interactions:
# Import timezone for date handling
from django.utils import timezone

# No questions initially
Question.objects.all()  # Returns <QuerySet []>

# Create and save a question
q = Question(question_text="What's new?", pub_date=timezone.now())
q.save()

# Access and modify attributes
q.id  # 1
q.question_text  # "What's new?"
q.pub_date  # datetime with tzinfo
q.question_text = "What's up?"
q.save()

# Retrieve all questions
Question.objects.all()  # <QuerySet [<Question: Question object (1)>]>
SECTION: Enhancing Model Representation
CONCEPT:
Add str() methods to models for better object representation.
Edit polls/models.py:
class Question(models.Model):
    # ...
    def __str__(self):
        return self.question_text

class Choice(models.Model):
    # ...
    def __str__(self):
        return self.choice_text
SECTION: Adding Custom Model Methods
CONCEPT:
Add methods like was_published_recently to models for custom logic.
Edit polls/models.py:
import datetime
from django.utils import timezone

class Question(models.Model):
    # ...
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
Reload shell after changes.
Further interactions:
# Filter and get
Question.objects.filter(id=1)  # <QuerySet [<Question: What's up?>]>
Question.objects.filter(question_text__startswith="What")  # <QuerySet [<Question: What's up?>]>
Question.objects.get(pub_date__year=timezone.now().year)  # <Question: What's up?>
Question.objects.get(pk=1)  # <Question: What's up?>

# Custom method
q = Question.objects.get(pk=1)
q.was_published_recently()  # True

# Create choices
q.choice_set.create(choice_text="Not much", votes=0)  # <Choice: Not much>
q.choice_set.all()  # <QuerySet [...]>
q.choice_set.count()  # 3

# Filter across relationships
Choice.objects.filter(question__pub_date__year=current_year)  # <QuerySet [...]>

# Delete
c = q.choice_set.filter(choice_text__startswith="Just hacking")
c.delete()
Use double underscores for relationship and field lookups.
SUMMARY:

Shell enables API testing.
str improves readability.
Custom methods add behavior.
API supports queries, relationships, and modifications.

SECTION: Django Admin Philosophy
CONCEPT:
Django automatically generates admin interfaces for models to manage content. Designed for site managers, not public users, with separation between content editing and public display.
SECTION: Creating Admin User
CONCEPT:
Create a superuser for admin access.
COMMAND:
python manage.py createsuperuser
Provide username, email, and password.
SECTION: Accessing the Admin Site
CONCEPT:
Start the development server if not running.
COMMAND:
python manage.py runserver
Access /admin/ at http://127.0.0.1:8000/admin/ and log in.
Admin index shows editable content like groups and users from auth.
SECTION: Registering Models in Admin
CONCEPT:
Register models to make them editable in admin.
Edit polls/admin.py:
from django.contrib import admin
from .models import Question

admin.site.register(Question)
SECTION: Exploring Admin Interface
CONCEPT:
Admin displays registered models on index. Change list shows all instances; select to edit.
Forms generate from model fields, with widgets for types (e.g., calendar for DateTimeField).
Options: Save, Save and continue editing, Save and add another, Delete.
History tracks changes with timestamps and users.
USAGE GUIDELINES:
USE WHEN:

Managing site content administratively.
DO NOT USE WHEN:
Exposing to public users; intended for managers.

SUMMARY:

Admin automates content management.
Register models for interfaces.
Provides editing, history, and shortcuts.
Separate from public site.