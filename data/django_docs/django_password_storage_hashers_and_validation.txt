SECTION: INTRODUCTION: PURPOSE:
Describe how Django manages passwords, including storage, hashing configuration, and helper utilities.

CONCEPT:
Django provides a secure and flexible system for storing and managing user passwords to avoid ad‑hoc password management implementations.
​
This document explains how passwords are stored and hashed, how to configure the hashing mechanism, and how to work with hashed passwords and password validation utilities.
​

USAGE GUIDELINES:
USE WHEN:

You configure or audit password handling for a Django project.
​

You need to choose, tune, or extend password hashers or validators.
​

DO NOT USE WHEN:

You attempt to design your own password storage scheme without integrating with Django’s provided mechanisms.
​

SUMMARY:
Django centralizes password storage and validation logic.
​

Hashers and validators are configurable and extensible.
​

SECTION: HOW DJANGO STORES PASSWORDS: PURPOSE:
Explain the password storage format and default hashing behavior.

CONCEPT:
Django provides a flexible password storage system and uses PBKDF2 with SHA256 as the default hasher.
​
The password attribute on User instances stores a string formatted as:
​

CODE:
<algorithm>$<iterations>$<salt>$<hash>
Each component represents the hasher name, the iteration count (work factor), the random salt, and the resulting password hash.
​
Django selects hashers from the PASSWORD_HASHERS setting, which lists supported hasher classes.
​

For storing passwords, Django uses the first entry in PASSWORD_HASHERS.
​
For verifying passwords, it selects the hasher whose algorithm name matches the stored password’s algorithm; if no matching hasher is configured, a ValueError is raised during verification.
​

The default PASSWORD_HASHERS is:
​

CODE:
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]
This configuration stores new passwords using PBKDF2-SHA256 while still allowing verification of PBKDF2-SHA1, Argon2, bcrypt, and scrypt hashes.
​

USAGE GUIDELINES:
USE WHEN:

You rely on Django’s default password storage behavior.
​

You ensure all required hashers remain in PASSWORD_HASHERS to keep older hashes verifiable.
​

DO NOT USE WHEN:

You remove hashers corresponding to existing stored passwords, which would break password verification.
​

SUMMARY:
Passwords are stored as algorithm$iterations$salt$hash strings.
​

PBKDF2-SHA256 is the default algorithm.
​

PASSWORD_HASHERS controls which hashers are used and which hashes can be verified.
​

SECTION: USING ARGON2 WITH DJANGO: PURPOSE:
Describe how to enable Argon2 as the default password hasher.

CONCEPT:
Argon2 is a next-generation password hashing algorithm designed to resist GPU and custom hardware attacks.
​
Django supports Argon2 via Argon2PasswordHasher, but it is not the default because it requires an external dependency.
​

To use Argon2id as the default storage algorithm:
​

Install the argon2-cffi package, for example with:

CODE:
 -m pip install django[argon2]
Configure PASSWORD_HASHERS with Argon2PasswordHasher first:

CODE:
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]
​

Keep existing entries to allow automatic upgrading of legacy password hashes.
​

USAGE GUIDELINES:
USE WHEN:

You want stronger, memory-hard password hashing and are comfortable adding argon2-cffi.
​

DO NOT USE WHEN:

You cannot install additional C‑backed dependencies in your deployment environment.
​

SUMMARY:
Argon2 is supported via Argon2PasswordHasher and argon2-cffi.
​

Place Argon2PasswordHasher first in PASSWORD_HASHERS to store new passwords with Argon2.
​

SECTION: USING BCRYPT WITH DJANGO: PURPOSE:
Describe how to enable bcrypt-based hashing.

CONCEPT:
bcrypt is a long‑standing password storage algorithm designed to be slow and computationally expensive, making brute‑force attacks harder.
​
Django supports bcrypt through BCryptSHA256PasswordHasher but does not use it by default because it requires a third‑party library.
​

To use bcrypt as the default storage algorithm:
​

Install the bcrypt package, for example with:

CODE:
-m pip install django[bcrypt]
Configure PASSWORD_HASHERS with BCryptSHA256PasswordHasher first:

CODE:
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]
​

Keep other entries in the list if you need Django to upgrade existing passwords.
​

USAGE GUIDELINES:
USE WHEN:

You prefer bcrypt’s behavior and are able to install the bcrypt dependency.
​

DO NOT USE WHEN:

You cannot manage external C‑backed libraries in your deployment environment.
​

SUMMARY:
bcrypt support is provided via BCryptSHA256PasswordHasher and the bcrypt package.
​

Put BCryptSHA256PasswordHasher first in PASSWORD_HASHERS to use bcrypt for new passwords.
​

SECTION: USING SCRYPT WITH DJANGO: PURPOSE:
Describe how to enable scrypt-based hashing.

CONCEPT:
scrypt is a memory-hard password derivation function that aims to limit parallel attacks by requiring more memory than PBKDF2 or bcrypt.
​
In Django, scrypt is implemented via ScryptPasswordHasher and requires OpenSSL 1.1+.
​

To use scrypt as the default storage algorithm:
​

python
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.ScryptPasswordHasher",
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
]
Keep additional entries to support upgrading from other algorithms.
​

USAGE GUIDELINES:
USE WHEN:

You want a memory-hard hasher and your runtime uses OpenSSL 1.1+.
​

DO NOT USE WHEN:

Your environment lacks adequate OpenSSL support.
​

SUMMARY:
scrypt is available via ScryptPasswordHasher and is memory‑intensive.
​

Set ScryptPasswordHasher first in PASSWORD_HASHERS to store new passwords with scrypt.
​

SECTION: INCREASING SALT ENTROPY: PURPOSE:
Describe how to adjust salt size for password hashes.

CONCEPT:
Most password hashes include a random salt to defend against rainbow table attacks.
​
Django’s BasePasswordHasher uses a default salt_entropy of 128 bits, which determines the minimum entropy of generated salts.
​

Because computing and storage costs change over time, advanced users may increase salt_entropy in custom hashers to raise salt entropy.
​
Due to the way salts are stored, salt_entropy acts as a minimum; actual entropy may be slightly higher (for example, 128 may yield 131 bits).
​

USAGE GUIDELINES:
USE WHEN:

You implement a custom password hasher and want stronger or tailored salt entropy.
​

DO NOT USE WHEN:

You rely solely on built‑in hashers and do not need to customize salt entropy.
​

SUMMARY:
Salts mitigate rainbow table attacks and are controlled by salt_entropy in BasePasswordHasher.
​

salt_entropy is a minimum entropy bound and can be overridden in custom hashers.
​

SECTION: INCREASING THE WORK FACTOR (PBKDF2/BCRYPT): PURPOSE:
Explain how to tune iteration counts or rounds for PBKDF2 and bcrypt.

CONCEPT:
PBKDF2 and bcrypt use iterations or rounds to slow down hashing and hinder brute‑force attacks.
​
As hardware improves, you should periodically increase the work factor to maintain adequate defense.
​

To increase iterations for PBKDF2, subclass PBKDF2PasswordHasher and override iterations.
​

COMMAND:
Example custom PBKDF2 hasher with higher iterations:

python
from django.contrib.auth.hashers import PBKDF2PasswordHasher


class MyPBKDF2PasswordHasher(PBKDF2PasswordHasher):
    """
    A subclass of PBKDF2PasswordHasher that uses 100 times more iterations.
    """
    iterations = PBKDF2PasswordHasher.iterations * 100
Add it as the first entry in PASSWORD_HASHERS:
​

python
PASSWORD_HASHERS = [
    "myproject.hashers.MyPBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]
bcrypt uses a logarithmic work factor (rounds), where 12 rounds corresponds to 
2
12
2 
12
  iterations.
​

USAGE GUIDELINES:
USE WHEN:

You need to strengthen hashing as hardware performance increases.
​

DO NOT USE WHEN:

You dramatically increase the work factor without testing impact on login latency.
​

SUMMARY:
PBKDF2 and bcrypt expose tunable work factors (iterations/rounds).
​

Create custom subclasses and list them first in PASSWORD_HASHERS to raise the work factor.
​

SECTION: TUNING ARGON2 PARAMETERS: PURPOSE:
Describe adjustable parameters for Argon2 in Django.

CONCEPT:
Argon2 exposes three tunable attributes:
​

time_cost: number of iterations of the hash.
​

memory_cost: memory usage in KiB during hashing.
​

parallelism: number of CPU threads used.
​

Default settings are appropriate for most deployments, but may be adjusted if hashing is too fast or too slow.
​

Recommended tuning process:
​

Choose parallelism as the thread count you can allocate to hashing.
​

Choose memory_cost as the amount of memory (KiB) you can allocate.
​

Adjust time_cost until hashing time is acceptable; if time_cost=1 is too slow, lower memory_cost.
​

memory_cost semantics differ from some Argon2 tools; Django’s value corresponds to 
2
memory_cost_commandline
2 
memory_cost_commandline
  in some command‑line utilities.
​

USAGE GUIDELINES:
USE WHEN:

You must fine‑tune Argon2 performance and security characteristics.
​

DO NOT USE WHEN:

You are unsure about safe parameter combinations; defaults are usually sufficient.
​

SUMMARY:
Argon2 supports tuning time, memory, and parallelism costs.
​

Adjust parameters carefully and measure actual hashing performance.
​

SECTION: TUNING SCRYPT PARAMETERS: PURPOSE:
Explain how to customize scrypt’s work and memory usage.

CONCEPT:
scrypt exposes parameters that determine iterations, memory usage, and parallelism:
​

work_factor (N): number of iterations and memory size; must be a power of 2.
​

block_size (r): internal block size affecting memory latency behavior.
​

parallelism (p): number of parallel computations.
​

maxmem: maximum memory allowed for hashing (0 uses OpenSSL’s default limit).
​

The minimum memory requirement is:
​

python
work_factor * 2 * block_size * 64
If the underlying scrypt implementation is multithreaded, memory usage is multiplied by parallelism.
​

USAGE GUIDELINES:
USE WHEN:

You need to carefully control scrypt’s CPU and memory footprint.
​

DO NOT USE WHEN:

You increase work_factor or block_size without updating maxmem appropriately.
​

SUMMARY:
scrypt parameters control both iterations and memory requirements.
​

Estimating memory usage is essential when tuning scrypt for your environment.
​

SECTION: PASSWORD UPGRADING: PURPOSE:
Explain automatic and manual upgrading of stored password hashes.

CONCEPT:
When a user logs in, if their password is stored with a non‑preferred algorithm, Django rewrites it using the preferred algorithm (the first in PASSWORD_HASHERS).
​
This allows older installs to become more secure over time and enables migration to new algorithms as they are introduced.
​

Django can only upgrade passwords that use algorithms listed in PASSWORD_HASHERS.
​
Therefore, DO NOT remove hashers from this list while you still have passwords encoded with those algorithms.
​

Upgrades also occur when increasing or decreasing PBKDF2 iterations, bcrypt rounds, or Argon2 parameters.
​

If some passwords use non‑default algorithms and others use the default, timing differences during login may expose a user enumeration side channel.
​
Upgrading older hashes reduces this risk.
​

USAGE GUIDELINES:
USE WHEN:

You adjust hashing algorithms or parameters and rely on login traffic to upgrade hashes.
​

DO NOT USE WHEN:

You remove all references to old hashers before their stored hashes have been upgraded.
​

SUMMARY:
Django updates hashes to the preferred algorithm at login time.
​

Keep legacy hashers in PASSWORD_HASHERS until all affected passwords are upgraded.
​

SECTION: PASSWORD UPGRADING WITHOUT LOGIN: PURPOSE:
Describe how to upgrade weak hashes proactively using a wrapped hasher and migration.

CONCEPT:
If an existing database uses weak hashes like MD5, you may want to upgrade them proactively instead of waiting for user logins.
​
A wrapped hasher pattern allows storing PBKDF2(MD5(password)) so you can migrate MD5 hashes while still verifying them.
​

Example: add a custom wrapped hasher.
​

COMMAND:
accounts/hashers.py:

python
from django.contrib.auth.hashers import (
    PBKDF2PasswordHasher,
    MD5PasswordHasher,
)


class PBKDF2WrappedMD5PasswordHasher(PBKDF2PasswordHasher):
    algorithm = "pbkdf2_wrapped_md5"

    def encode_md5_hash(self, md5_hash, salt, iterations=None):
        return super().encode(md5_hash, salt, iterations)

    def encode(self, password, salt, iterations=None):
        _, _, md5_hash = MD5PasswordHasher().encode(password, salt).split("$", 2)
        return self.encode_md5_hash(md5_hash, salt, iterations)
Data migration to rewrite existing MD5 hashes:
​

accounts/migrations/0002_migrate_md5_passwords.py:

CODE:
from django.db import migrations

from ..hashers import PBKDF2WrappedMD5PasswordHasher


def forwards_func(apps, schema_editor):
    User = apps.get_model("auth", "User")
    users = User.objects.filter(password__startswith="md5$")
    hasher = PBKDF2WrappedMD5PasswordHasher()
    for user in users:
        algorithm, salt, md5_hash = user.password.split("$", 2)
        user.password = hasher.encode_md5_hash(md5_hash, salt)
        user.save(update_fields=["password"])


class Migration(migrations.Migration):
    dependencies = [
        ("accounts", "0001_initial"),
        # replace this with the latest migration in contrib.auth
        ("auth", "####_migration_name"),
    ]

    operations = [
        migrations.RunPython(forwards_func),
    ]
This migration can take minutes for thousands of users, depending on hardware.
​

Update PASSWORD_HASHERS:
​

CODE:
PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "accounts.hashers.PBKDF2WrappedMD5PasswordHasher",
]
Include any other active hashers as needed.
​

USAGE GUIDELINES:
USE WHEN:

You must upgrade weak hashes (e.g., MD5) without relying on user logins.
​

DO NOT USE WHEN:

You cannot tolerate the migration runtime; plan maintenance windows for large datasets.
​

SUMMARY:
Wrapped hashers and data migrations can proactively upgrade legacy hashes.
​

Ensure corresponding hashers are present in PASSWORD_HASHERS during and after migration.
​

SECTION: INCLUDED HASHERS: PURPOSE:
List the password hashers shipped with Django and their algorithm names.

CONCEPT:
Django includes the following hashers:
​

CODE:
[
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.BCryptPasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
    "django.contrib.auth.hashers.MD5PasswordHasher",
]
The corresponding algorithm identifiers are:
​

pbkdf2_sha256

pbkdf2_sha1

argon2

bcrypt_sha256

bcrypt

scrypt

md5

USAGE GUIDELINES:
USE WHEN:

You configure PASSWORD_HASHERS or manually specify a hasher by algorithm name.
​

DO NOT USE WHEN:

You pick MD5 for new passwords; MD5 is weak and should be used only for legacy compatibility, if at all.
​

SUMMARY:
Django ships with PBKDF2, Argon2, bcrypt, scrypt, and MD5 hashers.
​

Each hasher has a specific algorithm name used in stored password strings.
​

SECTION: WRITING YOUR OWN HASHER: PURPOSE:
Describe the interface and security considerations for custom password hashers.

CONCEPT:
Custom hashers can be implemented when built‑in options do not fit a specific security or compatibility requirement.
​
If the hasher has a work factor (e.g., iterations), implement harden_runtime(self, password, encoded) to close timing gaps between old and new work factors.
​

For example, if encoded uses 20,000 iterations while the default hasher uses 30,000, harden_runtime should run the remaining 10,000 iterations.
​
If the hasher has no work factor, implement harden_runtime as a no‑op.
​

USAGE GUIDELINES:
USE WHEN:

You must integrate with existing password formats or specialized security requirements.
​

DO NOT USE WHEN:

Built‑in hashers already meet your project’s needs.
​

SUMMARY:
Custom hashers must implement harden_runtime if a work factor exists.
​

harden_runtime mitigates timing attacks related to mixed work factors.
​

SECTION: MANUALLY MANAGING A USER’S PASSWORD: PURPOSE:
Explain how to hash, check, and inspect passwords independently of the User model.

CONCEPT:
django.contrib.auth.hashers provides functions for manual password handling.
​

check_password(password, encoded, setter=None, preferred='default') compares a plain password with an encoded hash and returns True or False.
​

make_password(password, salt=None, hasher='default') creates an encoded hash; if password is None, it returns an unusable password value.
​

is_password_usable(encoded_password) returns False if the encoded password was created by User.set_unusable_password().
​

All functions also have asynchronous counterparts (acheck_password).
​

check_password optionally accepts a setter callable used to regenerate and update the stored hash when necessary, and preferred to choose a different hasher than the default.
​

COMMAND:

CODE:
from django.contrib.auth.hashers import check_password, make_password, is_password_usable

encoded = make_password("secret")
check_password("secret", encoded)  # True
is_password_usable(encoded)        # True

unusable = make_password(None)
is_password_usable(unusable)       # False
USAGE GUIDELINES:
USE WHEN:

You need password hashing and verification outside of the User model, such as in custom auth flows.
​

DO NOT USE WHEN:

You attempt to store raw passwords; always store encoded hashes.
​

SUMMARY:
check_password, make_password, and is_password_usable encapsulate low‑level password operations.
​

These utilities operate independently of any particular user model.
​

SECTION: PASSWORD VALIDATION OVERVIEW: PURPOSE:
Describe Django’s pluggable password validation system.

CONCEPT:
Users commonly choose weak passwords, so Django offers pluggable password validation to enforce password quality.
​
You can configure multiple validators via AUTH_PASSWORD_VALIDATORS; each validator provides help text and validation logic, and may react to password changes.
​

By default, the setting is an empty list, meaning no validation.
​
New projects created with Django’s default startproject template enable a recommended set of validators.
​

Validators are applied in password reset/change forms and in the createsuperuser and changepassword management commands.
​
Validators are not applied at the model level for methods like create_user() or create_superuser().
​

Even strong validation cannot guarantee passwords are strong in all contexts.
​

USAGE GUIDELINES:
USE WHEN:

You want to enforce password policies for end users.
​

DO NOT USE WHEN:

You assume validation alone guarantees strong passwords.
​

SUMMARY:
Password validators enforce configurable password policies.
​

Validators run in forms and management commands, not in model methods.
​

SECTION: ENABLING PASSWORD VALIDATION: PURPOSE:
Show how to configure validators via settings.

CONCEPT:
Password validation is configured through AUTH_PASSWORD_VALIDATORS.
​

COMMAND:
Example configuration enabling all built‑in validators:

CODE:
AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        "OPTIONS": {
            "min_length": 9,
        },
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]
This configuration:
​

Checks similarity between the password and user attributes (username, first name, last name, email by default).
​

Enforces a minimum length of 9 characters.
​

Rejects passwords found in a list of 20,000 common passwords.
​

Rejects passwords that are entirely numeric.
​

Validator help texts and error messages are returned in the order validators appear in AUTH_PASSWORD_VALIDATORS.
​

USAGE GUIDELINES:
USE WHEN:

You define project‑wide password policies using built‑in validators.
​

DO NOT USE WHEN:

You misconfigure AUTH_PASSWORD_VALIDATORS with missing or incorrect NAME paths.
​

SUMMARY:
AUTH_PASSWORD_VALIDATORS defines which validators apply and their options.
​

Order in the list controls help text and error ordering.
​

SECTION: INCLUDED PASSWORD VALIDATORS: PURPOSE:
Detail the built‑in password validators and their behavior.

CONCEPT:
Django includes four validators:
​

MinimumLengthValidator(min_length=8)

Validates that the password meets a minimum length.
​

get_error_message() allows customizing the ValidationError message and defaults to “This password is too short. It must contain at least <min_length> characters.”.
​

get_help_text() returns a help message, defaulting to “Your password must contain at least <min_length> characters.”.
​

UserAttributeSimilarityValidator(user_attributes=DEFAULT_USER_ATTRIBUTES, max_similarity=0.7)

Ensures the password is sufficiently different from selected user attributes (default: username, first_name, last_name, email).
​

Uses difflib.SequenceMatcher.quick_ratio() and rejects passwords above the configured max_similarity.
​

get_error_message() and get_help_text() can be customized; defaults mention similarity to user attributes.
​

CommonPasswordValidator(password_list_path=DEFAULT_PASSWORD_LIST_PATH)

Rejects passwords that appear in a list of 20,000 common passwords (case‑insensitive).
​

Accepts a custom password_list_path pointing to a plain text or gzipped wordlist.
​

get_error_message() defaults to “This password is too common.” and get_help_text() to “Your password can’t be a commonly used password.”.
​

NumericPasswordValidator

Rejects passwords composed entirely of digits.
​

get_error_message() defaults to “This password is entirely numeric.” and get_help_text() to “Your password can’t be entirely numeric.”.
​

These get_error_message() and get_help_text() hooks are available from Django 5.2 onward.
​

USAGE GUIDELINES:
USE WHEN:

You want to enforce length, similarity, common password, and numeric checks using built‑in tools.
​

DO NOT USE WHEN:

You use custom validators alone but forget to include any built‑in ones needed for baseline security.
​

SUMMARY:
Four built‑in validators cover length, personal similarity, common passwords, and numeric-only passwords.
​

Each validator offers customizable error messages and help text.
​

SECTION: INTEGRATING PASSWORD VALIDATION: PURPOSE:
Show how to call password validators from custom code and forms.

CONCEPT:
django.contrib.auth.password_validation exposes helper functions to integrate validation with custom forms or APIs.
​

Key functions:
​

validate_password(password, user=None, password_validators=None)

Validates a clear‑text password with configured validators.
​

Returns None if valid, otherwise raises ValidationError with all error messages.
​

If user is None, some validators may not perform checks and will accept any password.
​

password_changed(password, user=None, password_validators=None)

Notifies validators that a password has changed, enabling features like password reuse prevention.
​

For AbstractBaseUser subclasses, calling set_password() marks the password field as dirty and triggers password_changed() after saving.
​

password_validators_help_texts(password_validators=None)

Returns a list of help texts from all validators.
​

password_validators_help_text_html(password_validators=None)

Returns an HTML <ul> string with all help texts, suitable for form field help_text.
​

get_password_validators(validator_config)

Builds validator instances from a configuration structure identical to AUTH_PASSWORD_VALIDATORS.
​

Use this when you need a custom validator set for a particular use case.
​

All of these functions expect clear‑text passwords, not hashed passwords.
​

USAGE GUIDELINES:
USE WHEN:

You integrate password validation into custom forms, serializers, or API endpoints.
​

DO NOT USE WHEN:

You pass hashed passwords to validation functions; always supply clear‑text passwords.
​

SUMMARY:
Helper functions enable direct use of password validation logic in custom code.
​

Validators can be reused with default or custom configurations.
​

SECTION: WRITING YOUR OWN PASSWORD VALIDATOR: PURPOSE:
Describe the minimal interface for custom password validators.

CONCEPT:
Custom password validators are necessary when built‑in validators do not cover all policy requirements.
​
Each validator must implement at least:
​

validate(self, password, user=None):

Return None if the password is valid.
​

Raise ValidationError with an appropriate message if invalid.
​

Must gracefully handle user being None by returning None if it cannot perform meaningful checks.
​

get_help_text():

Return a string that explains the validator’s requirements to the user.
​

Any options in the OPTIONS dict for this validator in AUTH_PASSWORD_VALIDATORS are passed to its constructor, and all constructor parameters must have default values.
​

COMMAND:
Example custom validator with one optional setting:

CODE:
from django.core.exceptions import ValidationError
from django.utils.translation import gettext as _


class MinimumLengthValidator:
    def __init__(self, min_length=8):
        self.min_length = min_length

    def validate(self, password, user=None):
        if len(password) < self.min_length:
            raise ValidationError(
                _("This password must contain at least %(min_length)d characters."),
                code="password_too_short",
                params={"min_length": self.min_length},
            )

    def get_help_text(self):
        return _(
            "Your password must contain at least %(min_length)d characters."
            % {"min_length": self.min_length}
        )
Validators may additionally implement password_changed(password, user=None) to react to password changes (e.g., preventing password reuse) but must never store old passwords in clear text.
​

USAGE GUIDELINES:
USE WHEN:

You implement project‑specific password rules not covered by built‑in validators.
​

DO NOT USE WHEN:

You store previous passwords in plain text for reuse prevention; always store them hashed if stored at all.
​

SUMMARY:
Custom validators must implement validate and get_help_text and optionally password_changed.
​

Constructor options are configured via AUTH_PASSWORD_VALIDATORS.
​

VERSION AND SCOPE ANCHORS:
DJANGO VERSION: 6.0.
​
PYTHON VERSION: Not specified in this document.
​
APPLICABILITY: Django projects using the built‑in password storage, hashing, and validation mechanisms as described in Django 6.0 documentation.
​

SUMMARY:
Django centralizes password hashing, upgrading, and validation in configurable components.
​Hashers (PBKDF2, Argon2, bcrypt, scrypt) and validators are pluggable and tunable.
​Utilities support manual password operations and custom enforcement logic.
​Careful configuration avoids timing leaks and supports secure migration from legacy hashes.
