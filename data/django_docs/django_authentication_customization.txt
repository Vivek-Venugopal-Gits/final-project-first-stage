SECTION: CUSTOMIZING AUTHENTICATION IN DJANGO
PURPOSE: Details how to extend or replace parts of Django's authentication system, including backends, permissions, and user models.
Django's authentication system is extensible. Authentication backends allow authentication against different services. Custom permissions can be added to models. The default User model can be extended or fully substituted.
SECTION: OTHER AUTHENTICATION SOURCES
PURPOSE: Explains integrating external authentication sources like LDAP with Django's system.
Use alternative sources for usernames, passwords, or methods when Django's default database-based scheme does not suffice. Override the default or combine with other systems.
SECTION: SPECIFYING AUTHENTICATION BACKENDS
PURPOSE: Describes configuring the list of backends Django uses for authentication.
Django maintains a list of authentication backends checked sequentially during authentication attempts. If the first fails, proceed to the next until success or all fail.
Configure the list in the AUTHENTICATION_BACKENDS setting as a list of Python class paths.
By default, AUTHENTICATION_BACKENDS is set to ["django.contrib.auth.backends.ModelBackend"].
This default backend authenticates against the Django users database and handles built-in permissions without brute force protection. Implement rate limiting in a custom backend or via web server mechanisms.
Order in AUTHENTICATION_BACKENDS determines priority; stop at the first valid match.
If a backend raises PermissionDenied, authentication fails immediately without checking subsequent backends.
Once authenticated, store the backend in the user's session for reuse during the session. Clear session data after changing AUTHENTICATION_BACKENDS to force re-authentication.
USAGE GUIDELINES:
USE WHEN:

Needing multiple authentication methods or external sources.
DO NOT USE WHEN:
Default backend suffices, to avoid complexity.

SECTION: WRITING AN AUTHENTICATION BACKEND
PURPOSE: Guides creating a custom class for authentication logic.
An authentication backend is a class extending BaseBackend with required methods: get_user(user_id) and authenticate(request, **credentials).
The get_user method takes a user_id (primary key) and returns the user object or None.
The authenticate method takes a request (HttpRequest, may be None) and credentials as keywords, checks them, and returns the matching user or None.
COMMAND:
CODE:
from django.contrib.auth.backends import BaseBackend

class MyBackend(BaseBackend):
    def authenticate(self, request, username=None, password=None):
        # Check the username/password and return a user.
        ...
COMMAND:
CODE:
from django.contrib.auth.backends import BaseBackend

class MyBackend(BaseBackend):
    def authenticate(self, request, token=None):
        # Check the token and return a user.
        ...
For Django admin compatibility, ensure users have is_staff and is_active set to True.
Create Django User objects for external users, either via script or on first login.
COMMAND:
CODE:
from django.conf import settings
from django.contrib.auth.backends import BaseBackend
from django.contrib.auth.hashers import check_password
from django.contrib.auth.models import User

class SettingsBackend(BaseBackend):
    """
    Authenticate against the settings ADMIN_LOGIN and ADMIN_PASSWORD.

    Use the login name and a hash of the password. For example:

    ADMIN_LOGIN = 'admin'
    ADMIN_PASSWORD = 'pbkdf2_sha256$30000$Vo0VlMnkR4Bk$qEvtdyZRWTcOsCnI/oQ7fVOu1XAURIZYoOZ3iq8Dr4M='
    """

    def authenticate(self, request, username=None, password=None):
        login_valid = settings.ADMIN_LOGIN == username
        pwd_valid = check_password(password, settings.ADMIN_PASSWORD)
        if login_valid and pwd_valid:
            try:
                user = User.objects.get(username=username)
            except User.DoesNotExist:
                # Create a new user. There's no need to set a password
                # because only the password from settings.py is checked.
                user = User(username=username) # is_active defaults to True.
                user.is_staff = True
                user.is_superuser = True
                user.save()
            return user
        return None

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None
SECTION: HANDLING AUTHORIZATION IN CUSTOM BACKENDS
PURPOSE: Explains implementing permissions in custom backends.
User models and managers delegate permission lookups to backends that implement them. Permissions are the union from all backends.
If a backend raises PermissionDenied in has_perm or has_module_perms, authorization fails without checking further backends.
COMMAND:
CODE:
from django.contrib.auth.backends import BaseBackend

class MagicAdminBackend(BaseBackend):
    def has_perm(self, user_obj, perm, obj=None):
        return user_obj.username == settings.ADMIN_LOGIN
Backend functions take the user object (may be anonymous) as an argument.
SECTION: AUTHORIZATION FOR ANONYMOUS USERS
PURPOSE: Describes handling permissions for unauthenticated users.
Django's permission framework lacks storage for anonymous user permissions, but backends can specify behavior for AnonymousUser objects.
This supports scenarios where anonymous users have permissions, useful for reusable apps delegating authorization to backends.
SECTION: AUTHORIZATION FOR INACTIVE USERS
PURPOSE: Details handling inactive users in authentication.
Inactive users have is_active set to False. ModelBackend and RemoteUserBackend prevent their authentication.
Use AllowAllUsersModelBackend or AllowAllUsersRemoteUserBackend to allow inactive users.
Anonymous user support allows permissions for anonymous while denying for inactive authenticated users.
Test for is_active in custom backend permission methods.
SECTION: HANDLING OBJECT PERMISSIONS
PURPOSE: Explains the foundation for object-level permissions.
Django provides a foundation for object permissions but no core implementation; checks return False or empty lists.
Backends receive obj and user_obj in object-related methods and can implement accordingly.
SUMMARY:

Backends check sequentially for authentication and permissions.
Implement get_user and authenticate; optionally permission methods.
Handle anonymous and inactive users via backend logic.
Object permissions require custom backend implementation.

SECTION: CUSTOM PERMISSIONS
PURPOSE: Guides adding application-specific permissions to models.
Define custom permissions in the model's Meta permissions attribute as tuples of (codename, description).
COMMAND:
CODE:
class Task(models.Model):
    ...

    class Meta:
        permissions = [
            ("change_task_status", "Can change the status of tasks"),
            ("close_task", "Can remove a task by setting its status as closed"),
        ]
Run manage.py migrate to create permissions.
Check permissions in code using user.has_perm("app.close_task").
USAGE GUIDELINES:
USE WHEN:

Needing model-specific actions beyond add/change/delete.
DO NOT USE WHEN:
Standard permissions suffice.

SECTION: EXTENDING THE EXISTING USER MODEL
PURPOSE: Describes ways to add behavior or fields to the default User model without full substitution.
For behavioral changes without database alterations, use a proxy model based on User.
For additional fields, use a OneToOneField to a profile model.
COMMAND:
CODE:
from django.contrib.auth.models import User

class Employee(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    department = models.CharField(max_length=100)
Access related data via reverse relations.
COMMAND:
CODE:
u = User.objects.get(username="fsmith")
freds_department = u.employee.department
To include profile fields in admin, define an InlineModelAdmin and add to UserAdmin.
COMMAND:
CODE:
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User

from my_user_profile_app.models import Employee

# Define an inline admin descriptor for Employee model
# which acts a bit like a singleton
class EmployeeInline(admin.StackedInline):
    model = Employee
    can_delete = False
    verbose_name_plural = "employee"

# Define a new User admin
class UserAdmin(BaseUserAdmin):
    inlines = [EmployeeInline]

# Re-register UserAdmin
admin.site.unregister(User)
admin.site.register(User, UserAdmin)
Profile models are regular models; use post_save signals for auto-creation.
Related models incur extra queries; consider custom user for performance.
SECTION: SUBSTITUTING A CUSTOM USER MODEL
PURPOSE: Explains replacing the default User model for custom requirements like email as identifier.
Set AUTH_USER_MODEL to "app.ModelName".
COMMAND:
CODE:
AUTH_USER_MODEL = "myapp.MyUser"
SECTION: USING A CUSTOM USER MODEL WHEN STARTING A PROJECT
PURPOSE: Recommends subclassing AbstractUser for initial setup.
Subclass AbstractUser for identical behavior to default.
COMMAND:
CODE:
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    pass
Point AUTH_USER_MODEL to it before first migrations.
Register in admin.py using UserAdmin.
SECTION: CHANGING TO A CUSTOM USER MODEL MID-PROJECT
PURPOSE: Warns about complexities in switching user models after database creation.
Switching affects foreign keys and relations; requires manual schema fixes, data migration, and reapplying migrations.
The swappable model must be in the app's first migration to avoid dependency issues.
Resolve circular dependencies by splitting migrations.
SECTION: REUSABLE APPS AND AUTH_USER_MODEL
PURPOSE: Advises against custom user models in reusable apps.
Reusable apps should not define custom users to avoid conflicts; use ForeignKey or OneToOneField to AUTH_USER_MODEL for per-user data.
SECTION: REFERENCING THE USER MODEL
PURPOSE: Guides indirect referencing for compatibility with custom models.
Use django.contrib.auth.get_user_model() instead of direct User import.
For relations, use settings.AUTH_USER_MODEL.
COMMAND:
CODE:
from django.conf import settings
from django.db import models

class Article(models.Model):
    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
    )
For signals, use AUTH_USER_MODEL as sender.
COMMAND:
CODE:
from django.conf import settings
from django.db.models.signals import post_save

def post_save_receiver(sender, instance, created, **kwargs):
    pass

post_save.connect(post_save_receiver, sender=settings.AUTH_USER_MODEL)
Call get_user_model() at import time if needed.
Clear cache on AUTH_USER_MODEL changes using setting_changed signal.
SECTION: SPECIFYING A CUSTOM USER MODEL
PURPOSE: Details requirements for custom user models.
Inherit from AbstractBaseUser and provide USERNAME_FIELD (unique identifier), EMAIL_FIELD, REQUIRED_FIELDS, is_active, get_full_name(), get_short_name().
Import AbstractBaseUser from django.contrib.auth.base_user.
AbstractBaseUser provides: get_username(), clean(), normalize_username(), is_authenticated, is_anonymous, set_password(), check_password(), set_unusable_password(), has_usable_password(), get_session_auth_hash(), get_session_auth_fallback_hash().
AbstractUser subclasses AbstractBaseUser and adds clean() for email normalization.
For default backend, ensure unique identification field.
SECTION: WRITING A MANAGER FOR A CUSTOM USER MODEL
PURPOSE: Explains custom manager for handling user creation.
Extend BaseUserManager with create_user and create_superuser, accepting username field and required fields.
COMMAND:
CODE:
def create_user(self, email, date_of_birth, password=None):
    # create user here
    ...
BaseUserManager provides normalize_email(), get_by_natural_key().
SECTION: EXTENDING DJANGOâ€™S DEFAULT USER
PURPOSE: Suggests subclassing AbstractUser for additions.
Subclass AbstractUser to add fields while keeping default implementation.
Prefer separate profile for app-specific data to keep user model simple.
SECTION: CUSTOM USERS AND THE BUILT-IN AUTH FORMS
PURPOSE: Lists compatibility of auth forms with custom models.
AuthenticationForm, SetPasswordForm, PasswordChangeForm, AdminPasswordChangeForm work with AbstractBaseUser subclasses.
PasswordResetForm assumes email field and is_active.
UserCreationForm, UserChangeForm need extension for custom models.
COMMAND:
CODE:
from django.contrib.auth.forms import UserCreationForm
from myapp.models import CustomUser

class CustomUserCreationForm(UserCreationForm):
    class Meta(UserCreationForm.Meta):
        model = CustomUser
        fields = UserCreationForm.Meta.fields + ("custom_field",)
SECTION: CUSTOM USERS AND DJANGO.CONTRIB.ADMIN
PURPOSE: Details admin integration for custom users.
Define is_staff, is_active, has_perm(), has_module_perms().
Register with admin using UserAdmin for AbstractUser subclasses, or custom ModelAdmin for AbstractBaseUser.
Add custom fields to fieldsets and add_fieldsets.
SECTION: CUSTOM USERS AND PERMISSIONS
PURPOSE: Explains using PermissionsMixin for permission support.
Include PermissionsMixin for is_superuser, get_user_permissions(), get_group_permissions(), get_all_permissions(), has_perm(), has_perms(), has_module_perms().
Avoid invoking ModelBackend permissions without required fields.
SECTION: CUSTOM USERS AND PROXY MODELS
PURPOSE: Notes limitations with proxy models and custom users.
Custom user models break proxy models extending User; modify proxy to extend custom user or merge behavior.
SECTION: A FULL EXAMPLE
PURPOSE: Provides complete code for a custom user model using email and date of birth.
COMMAND:
CODE:
from django.db import models
from django.contrib.auth.models import BaseUserManager, AbstractBaseUser

class MyUserManager(BaseUserManager):
    def create_user(self, email, date_of_birth, password=None):
        """
        Creates and saves a User with the given email, date of
        birth and password.
        """
        if not email:
            raise ValueError("Users must have an email address")

        user = self.model(
            email=self.normalize_email(email),
            date_of_birth=date_of_birth,
        )

        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, date_of_birth, password=None):
        """
        Creates and saves a superuser with the given email, date of
        birth and password.
        """
        user = self.create_user(
            email,
            password=password,
            date_of_birth=date_of_birth,
        )
        user.is_admin = True
        user.save(using=self._db)
        return user

class MyUser(AbstractBaseUser):
    email = models.EmailField(
        verbose_name="email address",
        max_length=255,
        unique=True,
    )
    date_of_birth = models.DateField()
    is_active = models.BooleanField(default=True)
    is_admin = models.BooleanField(default=False)

    objects = MyUserManager()

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["date_of_birth"]

    def __str__(self):
        return self.email

    def has_perm(self, perm, obj=None):
        "Does the user have a specific permission?"
        # Simplest possible answer: Yes, always
        return True

    def has_module_perms(self, app_label):
        "Does the user have permissions to view the app `app_label`?"
        # Simplest possible answer: Yes, always
        return True

    @property
    def is_staff(self):
        "Is the user a member of staff?"
        # Simplest possible answer: All admins are staff
        return self.is_admin
For admin registration:
COMMAND:
CODE:
from django import forms
from django.contrib import admin
from django.contrib.auth.models import Group
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.forms import ReadOnlyPasswordHashField
from django.core.exceptions import ValidationError

from customauth.models import MyUser

class UserCreationForm(forms.ModelForm):
    """A form for creating new users. Includes all the required
    fields, plus a repeated password."""

    password1 = forms.CharField(label="Password", widget=forms.PasswordInput)
    password2 = forms.CharField(
        label="Password confirmation", widget=forms.PasswordInput
    )

    class Meta:
        model = MyUser
        fields = ["email", "date_of_birth"]

    def clean_password2(self):
        # Check that the two password entries match
        password1 = self.cleaned_data.get("password1")
        password2 = self.cleaned_data.get("password2")
        if password1 and password2 and password1 != password2:
            raise ValidationError("Passwords don't match")
        return password2

    def save(self, commit=True):
        # Save the provided password in hashed format
        user = super().save(commit=False)
        user.set_password(self.cleaned_data["password1"])
        if commit:
            user.save()
        return user

class UserChangeForm(forms.ModelForm):
    """A form for updating users. Includes all the fields on
    the user, but replaces the password field with admin's
    disabled password hash display field.
    """

    password = ReadOnlyPasswordHashField()

    class Meta:
        model = MyUser
        fields = ["email", "password", "date_of_birth", "is_active", "is_admin"]

class UserAdmin(BaseUserAdmin):
    # The forms to add and change user instances
    form = UserChangeForm
    add_form = UserCreationForm

    # The fields to be used in displaying the User model.
    # These override the definitions on the base UserAdmin
    # that reference specific fields on auth.User.
    list_display = ["email", "date_of_birth", "is_admin"]
    list_filter = ["is_admin"]
    fieldsets = [
        (None, {"fields": ["email", "password"]}),
        ("Personal info", {"fields": ["date_of_birth"]}),
        ("Permissions", {"fields": ["is_admin"]}),
    ]
    # add_fieldsets is not a standard ModelAdmin attribute. UserAdmin
    # overrides get_fieldsets to use this attribute when creating a user.
    add_fieldsets = [
        (
            None,
            {
                "classes": ["wide"],
                "fields": ["email", "date_of_birth", "password1", "password2"],
            },
        ),
    ]
    search_fields = ["email"]
    ordering = ["email"]
    filter_horizontal = []

Now register the new UserAdmin...
admin.site.register(MyUser, UserAdmin)
... and, since we're not using Django's built-in permissions,
unregister the Group model from admin.
admin.site.unregister(Group)
Set AUTH_USER_MODEL = "customauth.MyUser".
SECTION: ADDING AN ASYNC INTERFACE
PURPOSE: Describes optional async methods for performance in async contexts.
Implement aget_user(user_id) and aauthenticate(request, **credentials) for native async support.
If not provided when extending BaseBackend, sync versions are adapted with sync_to_async, incurring performance costs.
Out-of-the-box backends have async support; modify async versions when extending.
SUMMARY:

Subclass AbstractBaseUser or AbstractUser for custom models.
Define custom managers with create_user and create_superuser.
Ensure compatibility with forms, admin, and permissions.
Use get_user_model() for references.

SECTION: VERSION COMPATIBILITY
DJANGO VERSION: 6.0
PYTHON VERSION: Not specified in document
APPLICABILITY: - Applies to projects requiring custom auth; backward-compatible with noted versions.