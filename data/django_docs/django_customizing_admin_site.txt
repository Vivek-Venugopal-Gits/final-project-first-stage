SECTION: Tutorial Overview - Writing Your First Django App, Part 7
PURPOSE:
This section continues the poll application tutorial by customizing the automatically-generated admin site.
SECTION: Customizing the Admin Form
CONCEPT:
Customize admin forms by creating a ModelAdmin subclass and passing it to admin.site.register(). This allows reordering fields or grouping into fieldsets.
Code for polls/admin.py:
from django.contrib import admin

from .models import Question

class QuestionAdmin(admin.ModelAdmin):
    fields = ["pub_date", "question_text"]

admin.site.register(Question, QuestionAdmin)
This reorders pub_date before question_text.
For larger forms, use fieldsets:
Code for polls/admin.py:
class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, {"fields": ["question_text"]}),
        ("Date information", {"fields": ["pub_date"]}),
    ]
Fieldsets group fields with titles.
USAGE GUIDELINES:
USE WHEN:

Improving usability for forms with many fields.
DO NOT USE WHEN:
Default form order is sufficient.

SECTION: Adding Related Objects in Admin
CONCEPT:
Register related models like Choice for inline editing in Question admin.
Initially, register Choice separately:
Code for polls/admin.py:
from django.contrib import admin

from .models import Choice, Question

admin.site.register(Choice)
This provides a separate Add choice form with Question select box and Add another question link.
For inline editing, remove Choice registration and use inline in QuestionAdmin:
Code for polls/admin.py:
class ChoiceInline(admin.StackedInline):
    model = Choice
    extra = 3

class QuestionAdmin(admin.ModelAdmin):
    fieldsets = [
        (None, {"fields": ["question_text"]}),
        ("Date information", {"fields": ["pub_date"], "classes": ["collapse"]}),
    ]
    inlines = [ChoiceInline]

admin.site.register(Question, QuestionAdmin)
Provides 3 Choice slots in Question form; add more dynamically.
Use TabularInline for compact table format:
Code for polls/admin.py:
class ChoiceInline(admin.TabularInline):
    # ...
Includes Delete? column for removals.
USAGE GUIDELINES:
USE WHEN:

Editing related objects together.
DO NOT USE WHEN:
Models are independent.

SUMMARY:

Register related models for separate forms.
Use inlines for embedded editing.
Stacked or tabular for layout.

SECTION: Customizing the Admin Change List
CONCEPT:
Customize change list with list_display for columns, list_filter for filters, and search_fields for search.
Code for polls/admin.py:
class QuestionAdmin(admin.ModelAdmin):
    # ...
    list_display = ["question_text", "pub_date", "was_published_recently"]
    list_filter = ["pub_date"]
    search_fields = ["question_text"]
list_display enables sorting (except custom methods unless decorated).
Decorate custom methods:
Code for polls/models.py:
from django.contrib import admin

class Question(models.Model):
    # ...
    @admin.display(
        boolean=True,
        ordering="pub_date",
        description="Published recently?",
    )
    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now
Pagination defaults to 100 items per page.
USAGE GUIDELINES:
USE WHEN:

Enhancing list usability.
DO NOT USE WHEN:
Default list is adequate.

SECTION: Customizing the Admin Look and Feel
CONCEPT:
Override admin templates by copying from Django source and modifying in project templates.
SECTION: Customizing Project Templates
CONCEPT:
Add DIRS to TEMPLATES in settings.py for project templates.
Code for mysite/settings.py:
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]
Copy admin/base_site.html to templates/admin and customize branding.
COMMAND:
To find Django source:
python -c "import django; print(django.__path__)"
SECTION: Customizing Application Templates
CONCEPT:
Place app-specific templates in app/templates for fallback via APP_DIRS.
Prefer app templates for portability.
USAGE GUIDELINES:
USE WHEN:

Overriding specific admin templates.
DO NOT USE WHEN:
Changes can be made via AdminSite attributes like site_header.

SECTION: Customizing the Admin Index Page
CONCEPT:
Override admin/index.html to customize app list layout.
Hardcode links instead of using app_list variable.
SUMMARY:

Override templates for custom look.
Use project or app directories.
Customize index for usability.